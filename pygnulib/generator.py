#!/usr/bin/python
# encoding: UTF-8
"""gnulib generators API"""



import os as _os
import re as _re
import codecs as _codecs
import subprocess as _sp
from datetime import datetime as _datetime


from .error import type_assert as _type_assert
from .config import Base as _BaseConfig
from .module import Base as _BaseModule
from .config import LGPLv2_LICENSE as _LGPLv2_LICENSE
from .config import LGPLv3_LICENSE as _LGPLv3_LICENSE
from .config import GPLv2_LICENSE as _GPLv2_LICENSE
from .config import LGPL_LICENSE as _LGPL_LICENSE




_LGPL = {
    _LGPLv2_LICENSE: "2",
    _LGPLv3_LICENSE: "3",
    _LGPL_LICENSE: "yes",
    (_GPLv2_LICENSE | _LGPLv3_LICENSE): "3orGPLv2",
}
_ITERABLES = frozenset((list, tuple, set, frozenset, type({}.keys()), type({}.values())))



class Base:
    """gnulib file content generator"""
    _TEMPLATE = (
        "## DO NOT EDIT! GENERATED AUTOMATICALLY!",
        "#",
        "# This file is free software; you can redistribute it and/or modify",
        "# it under the terms of the GNU General Public License as published by",
        "# the Free Software Foundation; either version 3 of the License, or",
        "# (at your option) any later version.",
        "#",
        "# This file is distributed in the hope that it will be useful,",
        "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
        "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        "# GNU General Public License for more details.",
        "#",
        "# You should have received a copy of the GNU General Public License",
        "# along with this file.  If not, see <http://www.gnu.org/licenses/>.",
        "#",
        "# As a special exception to the GNU General Public License,",
        "# this file may be distributed as part of a program that",
        "# contains a configuration script generated by Autoconf, under",
        "# the same distribution terms as the rest of that program.",
        "#",
        "# Generated by gnulib-tool.",
    )


    def __repr__(self):
        module = self.__class__.__module__
        name = self.__class__.__name__
        return "{0}.{1}".format(module, name)


    def __str__(self):
        return "\n".join([_ for _ in self])


    def __enter__(self):
        return self


    def __exit__(self, exctype, excval, exctrace):
        pass


    def __iter__(self):
        for line in Base._TEMPLATE:
            yield line



class POMakevars(Base):
    """PO Makefile parameterization"""
    _TEMPLATE = (
        "# These options get passed to xgettext.",
        "XGETTEXT_OPTIONS = \\",
        "  --keyword=_ --flag=_:1:pass-c-format \\",
        "  --keyword=N_ --flag=N_:1:pass-c-format \\",
        "  --keyword='proper_name:1,\"This is a proper name." # comma omitted
        " See the gettext manual, section Names.\"' \\",
        "  --keyword='proper_name_utf8:1,\"This is a proper name." # comma omitted
        " See the gettext manual, section Names.\"' \\",
        "  --flag=error:3:c-format --flag=error_at_line:5:c-format",
        "",
        "# This is the copyright holder that gets inserted into the header of the",
        "# $(DOMAIN).pot file.  gnulib is copyrighted by the FSF.",
        "COPYRIGHT_HOLDER = Free Software Foundation, Inc.",
        "",
        "# This is the email address or URL to which the translators shall report",
        "# bugs in the untranslated strings:",
        "# - Strings which are not entire sentences, see the maintainer guidelines",
        "#   in the GNU gettext documentation, section 'Preparing Strings'.",
        "# - Strings which use unclear terms or require additional context to be",
        "#   understood.",
        "# - Strings which make invalid assumptions about notation of date, time or",
        "#   money.",
        "# - Pluralisation problems.",
        "# - Incorrect English spelling.",
        "# - Incorrect formatting.",
        "# It can be your email address, or a mailing list address where translators",
        "# can write to without being subscribed, or the URL of a web page through",
        "# which the translators can contact you.",
        "MSGID_BUGS_ADDRESS = bug-gnulib@gnu.org",
        "",
        "# This is the list of locale categories, beyond LC_MESSAGES, for which the",
        "# message catalogs shall be used.  It is usually empty.",
        "EXTRA_LOCALE_CATEGORIES =",
        "",
        "# This tells whether the $(DOMAIN).pot file contains messages with an 'msgctxt'",
        "# context.  Possible values are \"yes\" and \"no\".  Set this to yes if the",
        "# package uses functions taking also a message context, like pgettext(), or",
        "# if in $(XGETTEXT_OPTIONS) you define keywords with a context argument.",
        "USE_MSGCTXT = no"
    )


    def __init__(self, config):
        _type_assert("config", config, _BaseConfig)
        super().__init__()
        self.__config = config


    @property
    def po_base(self):
        """directory relative to ROOT where *.po files are placed; defaults to 'po'"""
        return self.__config.po_base


    @property
    def po_domain(self):
        """the prefix of the i18n domain"""
        return self.__config.po_domain


    def __repr__(self):
        module = self.__class__.__module__
        name = self.__class__.__name__
        fmt = "{}.{}{po_base={}, po_domain={}}"
        return fmt.format(module, name, repr(self.__config.po_base), repr(self.__config.po_domain))


    def __iter__(self):
        for line in super().__iter__():
            yield line
        yield "# Usually the message domain is the same as the package name."
        yield "# But here it has a '-gnulib' suffix."
        yield "DOMAIN = {}-gnulib".format(self.po_domain)
        yield ""
        yield "# These two variables depend on the location of this directory."
        yield "subdir = {}".format(self.po_domain)
        yield "top_subdir = {}".format("/".join(".." for _ in self.po_base.split(_os.path.sep)))
        for line in POMakevars._TEMPLATE:
            yield line



class POTFILES(Base):
    """file list to be passed to xgettext"""
    def __init__(self, config, files):
        _type_assert("config", config, _BaseConfig)
        super().__init__()
        self.__config = config
        self.__files = tuple(files)


    @property
    def files(self):
        """list of files"""
        return tuple(self.files)


    def __repr__(self):
        module = self.__class__.__module__
        name = self.__class__.__name__
        fmt = "{}.{}{files={}}"
        return fmt.format(module, name, repr(self.__files))


    def __iter__(self):
        for line in super().__iter__():
            yield line
        yield "# List of files which contain translatable strings."
        for file in [_ for _ in self.files if _.startswith("lib/")]:
            yield _os.path.join(self.__config.source_base, file[4:])



class AutoconfSnippet(Base):
    """autoconf snippet generator for standalone module"""
    def __init__(self, config, module, toplevel, no_libtool, no_gettext):
        """
        config: gnulib configuration
        module: gnulib module instance
        toplevel: make a subordinate use of gnulib if False
        no_libtool: disable libtool (regardless of configuration)
        no_gettext: disable AM_GNU_GETTEXT invocations if True
        """
        _type_assert("config", config, _BaseConfig)
        _type_assert("module", module, _BaseModule)
        _type_assert("toplevel", toplevel, bool)
        _type_assert("no_libtool", no_libtool, bool)
        _type_assert("no_gettext", no_gettext, bool)
        super().__init__()
        self.__config = config
        self.__module = module
        self.__toplevel = toplevel
        self.__no_libtool = no_libtool
        self.__no_gettext = no_gettext


    @property
    def toplevel(self):
        """top level indicator; subordinate use of pygnulib"""
        return self.__toplevel


    @property
    def libtool(self):
        """libtool switch, disabling libtool configuration parameter"""
        return self.__config.libtool and not self.__no_libtool


    @property
    def gettext(self):
        """gettext switch, disabling AM_GNU_GETTEXT invocations"""
        return not self.__no_gettext


    def __repr__(self):
        flags = []
        module = self.__class__.__module__
        name = self.__class__.__name__
        if self.toplevel:
            flags += ["toplevel"]
        if self.libtool:
            flags += ["libtool"]
        if self.gettext:
            flags += ["gettext"]
        include_guard_prefix = self.__config.include_guard_prefix
        flags = "|".join(flags)
        fmt = "{}.{}{include_guard_prefix={}, flags={}}"
        return fmt.format(module, name, repr(include_guard_prefix), flags)


    def __iter__(self):
        module = self.__module
        if module.name not in ("gnumakefile", "maintainer-makefile") or self.toplevel:
            snippet = module.autoconf_snippet
            include_guard_prefix = self.__config.include_guard_prefix
            snippet.replace(r"${gl_include_guard_prefix}", include_guard_prefix)
            if not self.libtool:
                table = (
                    (r"$gl_cond_libtool", "false"),
                    ("gl_libdeps", "gltests_libdeps"),
                    ("gl_ltlibdeps", "gltests_ltlibdeps"),
                )
                for (src, dst) in table:
                    snippet = snippet.replace(src, dst)
            if not self.gettext:
                src = "AM_GNU_GETTEXT([external])"
                dst = "dnl you must add AM_GNU_GETTEXT([external]) or similar to configure.ac.'"
                snippet = snippet.replace(src, dst)
            else:
                # Don't indent AM_GNU_GETTEXT_VERSION line, as that confuses
                # autopoint through at least GNU gettext version 0.18.2.
                snippet = snippet.lstrip()
            lines = (_ for _ in snippet.split("\n") if _)
            for line in lines:
                yield line
            if module.name == "alloca" and self.libtool:
                yield "changequote(,)dnl"
                yield "LTALLOCA=`echo \"$ALLOCA\" | sed -e 's/\\.[^.]* /.lo /g;s/\\.[^.]*$/.lo/'`"
                yield "changequote([, ])dnl"
                yield "AC_SUBST([LTALLOCA])"



class InitMacro(Base):
    """basic gl_INIT macro generator"""
    def __init__(self, config, macro_prefix=None):
        """
        config: gnulib configuration
        macro_prefix: macro prefix; if None, consider configuration
        """
        _type_assert("config", config, _BaseConfig)
        if macro_prefix is None:
            macro_prefix = config.macro_prefix
        _type_assert("macro_prefix", macro_prefix, str)
        self.__macro_prefix = macro_prefix


    @property
    def macro_prefix(self):
        """the prefix of the macros 'gl_EARLY' and 'gl_INIT'"""
        return self.__macro_prefix


    def __repr__(self):
        module = self.__class__.__module__
        name = self.__class__.__name__
        fmt = "{}.{}{macro_prefix={}}"
        return fmt.format(module, name, repr(self.__macro_prefix))



class InitMacroHeader(InitMacro):
    """the first few statements of the gl_INIT macro"""
    _TEMPLATE = (
        # Overriding AC_LIBOBJ and AC_REPLACE_FUNCS has the effect of storing
        # platform-dependent object files in ${macro_prefix_arg}_LIBOBJS instead
        # of LIBOBJS. The purpose is to allow several gnulib instantiations under
        # a single configure.ac file. (AC_CONFIG_LIBOBJ_DIR does not allow this
        # flexibility).
        # Furthermore it avoids an automake error like this when a Makefile.am
        # that uses pieces of gnulib also uses $(LIBOBJ):
        #   automatically discovered file `error.c' should not be explicitly
        #   mentioned.
        "  m4_pushdef([AC_LIBOBJ], m4_defn([{macro_prefix}_LIBOBJ]))",
        "  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([{macro_prefix}_REPLACE_FUNCS]))",

        # Overriding AC_LIBSOURCES has the same purpose of avoiding the automake
        # error when a Makefile.am that uses pieces of gnulib also uses $(LIBOBJ):
        #   automatically discovered file `error.c' should not be explicitly
        #   mentioned
        # We let automake know about the files to be distributed through the
        # EXTRA_lib_SOURCES variable.
        "  m4_pushdef([AC_LIBSOURCES], m4_defn([{macro_prefix}_LIBSOURCES]))",

        # Create data variables for checking the presence of files that are
        # mentioned as AC_LIBSOURCES arguments. These are m4 variables, not shell
        # variables, because we want the check to happen when the configure file is
        # created, not when it is run. ${macro_prefix_arg}_LIBSOURCES_LIST is the
        # list of files to check for. ${macro_prefix_arg}_LIBSOURCES_DIR is the
        # subdirectory in which to expect them.
        "  m4_pushdef([{macro_prefix}_LIBSOURCES_LIST], [])",
        "  m4_pushdef([{macro_prefix}_LIBSOURCES_DIR], [])",
        "  gl_COMMON",
    )


    def __init__(self, config, macro_prefix=None):
        """
        config: gnulib configuration
        macro_prefix: macro prefix; if None, consider configuration
        """
        super().__init__(config=config, macro_prefix=macro_prefix)


    def __iter__(self):
        macro_prefix = self.macro_prefix
        for line in InitMacroHeader._TEMPLATE:
            yield line.format(macro_prefix=macro_prefix)



class InitMacroFooter(InitMacro):
    """the last few statements of the gl_INIT macro"""
    _TEMPLATE = (
        "  m4_ifval({macro_prefix}_LIBSOURCES_LIST, [",
        "    m4_syscmd([test ! -d ]m4_defn([{macro_prefix}_LIBSOURCES_DIR])[ ||",
        "      for gl_file in ]{macro_prefix}_LIBSOURCES_LIST[ ; do",
        "        if test ! -r ]m4_defn([{macro_prefix}_LIBSOURCES_DIR])[/$gl_file ; then",
        "          echo \"missing file ]m4_defn([{macro_prefix}_LIBSOURCES_DIR])[/$gl_file\" >&2",
        "          exit 1",
        "        fi",
        "      done])dnl",
        "      m4_if(m4_sysval, [0], [],",
        "        [AC_FATAL([expected source file, required through AC_LIBSOURCES, not found])])",
        "  ])",
        "  m4_popdef([{macro_prefix}_LIBSOURCES_DIR])",
        "  m4_popdef([{macro_prefix}_LIBSOURCES_LIST])",
        "  m4_popdef([AC_LIBSOURCES])",
        "  m4_popdef([AC_REPLACE_FUNCS])",
        "  m4_popdef([AC_LIBOBJ])",
        "  AC_CONFIG_COMMANDS_PRE([",
        "    {macro_prefix}_libobjs=",
        "    {macro_prefix}_ltlibobjs=",
        "    if test -n \"${macro_prefix}_LIBOBJS\"; then",
        "      # Remove the extension.",
        "      sed_drop_objext='s/\\.o$//;s/\\.obj$//'",
        "      for i in `for i in ${macro_prefix}_LIBOBJS; " # comma omitted
        "do echo \"$i\"; done | sed -e \"$sed_drop_objext\" | sort | uniq`; do",
        "        {macro_prefix}_libobjs=\"${macro_prefix}_libobjs $i.$ac_objext\"",
        "        {macro_prefix}_ltlibobjs=\"${macro_prefix}_ltlibobjs $i.lo\"",
        "      done",
        "    fi",
        "    AC_SUBST([{macro_prefix}_LIBOBJS], [${macro_prefix}_libobjs])",
        "    AC_SUBST([{macro_prefix}_LTLIBOBJS], [${macro_prefix}_ltlibobjs])",
        "  ])",
    )


    def __init__(self, config, macro_prefix=None):
        """
        config: gnulib configuration
        macro_prefix: macro prefix; if None, consider configuration
        """
        super().__init__(config=config, macro_prefix=macro_prefix)


    def __iter__(self):
        # Check the presence of files that are mentioned as AC_LIBSOURCES
        # arguments. The check is performed only when autoconf is run from the
        # directory where the configure.ac resides; if it is run from a different
        # directory, the check is skipped.
        for line in InitMacroFooter._TEMPLATE:
            yield line.format(macro_prefix=self.macro_prefix)



class InitMacroDone(InitMacro):
    """few statements AFTER the gl_INIT macro"""
    _TEMPLATE = (
        "",
        "# Like AC_LIBOBJ, except that the module name goes",
        "# into {macro_prefix}_LIBOBJS instead of into LIBOBJS.",
        "AC_DEFUN([{macro_prefix}_LIBOBJ], [",
        "  AS_LITERAL_IF([$1], [{macro_prefix}_LIBSOURCES([$1.c])])dnl",
        "  {macro_prefix}_LIBOBJS=\"${macro_prefix}_LIBOBJS $1.$ac_objext\"",
        "])",
        "",
        "# Like AC_REPLACE_FUNCS, except that the module name goes",
        "# into {macro_prefix}_LIBOBJS instead of into LIBOBJS.",
        "AC_DEFUN([{macro_prefix}_REPLACE_FUNCS], [",
        "  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl",
        "  AC_CHECK_FUNCS([$1], , [{macro_prefix}_LIBOBJ($ac_func)])",
        "])",
        "",
        "# Like AC_LIBSOURCES, except the directory where the source file is",
        "# expected is derived from the gnulib-tool parameterization,",
        "# and alloca is special cased (for the alloca-opt module).",
        "# We could also entirely rely on EXTRA_lib..._SOURCES.",
        "AC_DEFUN([{macro_prefix}_LIBSOURCES], [",
        "  m4_foreach([_gl_NAME], [$1], [",
        "    m4_if(_gl_NAME, [alloca.c], [], [",
        "      m4_define([{macro_prefix}_LIBSOURCES_DIR], [{source_base}])",
        "      m4_append([{macro_prefix}_LIBSOURCES_LIST], _gl_NAME, [ ])",
        "    ])",
        "  ])",
        "])",
    )


    def __init__(self, config, source_base=None, macro_prefix=None):
        super().__init__(config=config, macro_prefix=macro_prefix)
        if source_base is None:
            source_base = config.source_base
        _type_assert("source_base", source_base, str)
        self.__source_base = source_base


    @property
    def source_base(self):
        """directory relative to ROOT where source code is placed; defaults to 'lib'"""
        return self.__source_base


    def __iter__(self):
        for line in InitMacroDone._TEMPLATE:
            yield line.format(source_base=self.__source_base, macro_prefix=self.macro_prefix)



class CommandLine(Base):
    """gnulib command-line invocation generator"""
    _TESTS = {
        "tests": "tests",
        "obsolete": "obsolete",
        "cxx_tests": "c++-tests",
        "longrunning_tests": "longrunning-tests",
        "privileged_tests": "privileged-tests",
        "unportable_tests": "unportable-tests",
    }

    def __init__(self, config, explicit):
        _type_assert("config", config, _BaseConfig)
        _type_assert("explicit", explicit, _ITERABLES)
        self.__config = config
        self.__explicit = explicit


    def __iter__(self):
        config = self.__config
        explicit = self.__explicit
        yield "gnulib-tool --import"
        for path in config.overrides:
            yield "--local-dir={}".format(path)
        yield "--lib={}".format(config.libname)
        yield "--source-base={}".format(config.source_base)
        yield "--m4-base={}".format(config.m4_base)
        if "po_base" in explicit:
            yield "--po-base={}".format(config.po_base)
        yield "--doc-base={}".format(config.doc_base)
        yield "--tests-base={}".format(config.tests_base)
        yield "--aux-dir={}".format(config.auxdir)
        for (key, value) in CommandLine._TESTS.items():
            if config[key]:
                yield "--with-{}".format(value)
        if config.all_tests:
            yield "--with-all-tests"
        for module in config.avoids:
            yield "--avoid={}".format(module)
        if config.licenses in _LGPL:
            lgpl = _LGPL[config.licenses]
            yield "--lgpl={}".format(lgpl) if lgpl != "yes" else "--lgpl"
        if config.gnumake:
            yield "--gnu-make"
        if "makefile_name" in explicit:
            yield "--makefile-name={}".format(config.makefile_name)
        yield "--{}conditional-dependencies".format("" if config.conddeps else "no-")
        yield "--{}libtool".format("" if config.libtool else "no-")
        yield "--macro-prefix={}".format(config.macro_prefix)
        if "po_domain" in explicit:
            yield "--po-domain={}".format(config.po_domain)
        if "witness_c_macro" in explicit:
            yield "--witness-c-macro={}".format(config.witness_c_macro)
        if "vc_files" in explicit:
            yield "--{}vc-files".format("" if config.vc_files else "no-")
        for module in sorted(config.modules):
            yield "{}".format(module)



class LibMakefile(Base):
    _LDFLAGS = _re.compile(r"^lib_LDFLAGS\s*\+\=.*?$", _re.S)
    _LIBNAME = _re.compile(r"lib_([A-Z][A-Z]*)", _re.S)
    _GNUMAKE = _re.compile(r"^if (.*?)$", _re.S)


    def __init__(self, config, explicit, path, modules, mkedits, for_test):
        _type_assert("config", config, _BaseConfig)
        _type_assert("explicit", explicit, _ITERABLES)
        _type_assert("path", path, str)
        _type_assert("modules", modules, _ITERABLES)
        _type_assert("mkedits", mkedits, _ITERABLES)
        _type_assert("for_test", for_test, bool)
        self.__config = config
        self.__explicit = explicit
        self.__path = path
        self.__modules = modules
        self.__mkedits = mkedits
        self.__for_test = for_test


    def __iter__(self):
        date = _datetime.now()
        config = self.__config
        explicit = self.__explicit
        for_test = self.__for_test
        modules = self.__modules

        gnumake = config.gnumake
        libtool = config.libtool
        kwargs = {
            "libname": config.libname,
            "macro_prefix": config.macro_prefix,
            "libext": "la" if libtool else "a",
            "perhaps_LT": "LT" if libtool else "",
        }
        assign = "+=" if gnumake or "makefile_name" in explicit else "="
        eliminate_LDFLAGS = True if libtool else False

        # When creating a package for testing: Attempt to provoke failures,
        # especially link errors, already during "make" rather than during
        # "make check", because "make check" is not possible in a cross-compiling
        # situation. Turn check_PROGRAMS into noinst_PROGRAMS.
        transform_check_PROGRAMS = True if for_test else False

        yield "## DO NOT EDIT! GENERATED AUTOMATICALLY!"
        yield "## Process this file with automake to produce Makefile.in."
        yield "# Copyright (C) 2002-{} Free Software Foundation, Inc.".format(date.year)
        for line in super().__iter__():
            yield line

        # The maximum line length (excluding the terminating newline) of any file
        # that is to be preprocessed by config.status is 3070.  config.status uses
        # awk, and the HP-UX 11.00 awk fails if a line has length >= 3071;
        # similarly, the IRIX 6.5 awk fails if a line has length >= 3072.
        actioncmd = " ".join(CommandLine(config, explicit))
        if len(actioncmd) <= 3000:
            yield "# Reproduce by: {}".format(actioncmd)
        yield ""

        def _snippet():
            lines = []

            def _common_conditional(module, conditional, unconditional):
                yield ""
                yield "if {}".format(module.conditional_name)
                yield conditional
                yield "endif"
                yield unconditional

            def _common_unconditional(module, conditional, unconditional):
                yield ""
                yield conditional
                yield unconditional

            def _gnumake_conditional(module, conditional, unconditional):
                yield "ifeq (,$(OMIT_GNULIB_MODULE_{}))".format(module.name)
                yield ""
                yield "ifneq (,$({}))".format(module.conditional_name)
                yield LibMakefile._GNUMAKE.sub("ifneq (,$(\\1))", conditional)
                yield "endif"
                yield "endif"
                yield LibMakefile._GNUMAKE.sub("ifneq (,$(\\1))", unconditional)

            def _gnumake_unconditional(module, conditional, unconditional):
                yield ""
                yield LibMakefile._GNUMAKE.sub("ifneq (,$(\\1))", conditional)
                yield LibMakefile._GNUMAKE.sub("ifneq (,$(\\1))", unconditional)

            uses_subdirs = False
            process = (
                (_common_unconditional, _gnumake_unconditional),
                (_common_conditional, _gnumake_conditional),
            )[config.conddeps][gnumake]
            for module in sorted(modules):
                if module.name.endswith("-tests"):
                    continue
                conditional = module.conditional_automake_snippet
                conditional = conditional.replace("lib_LIBRARIES", "lib%_LIBRARIES")
                conditional = conditional.replace("lib_LTLIBRARIES", "lib%_LTLIBRARIES")
                if eliminate_LDFLAGS:
                    conditional = LibMakefile._LDFLAGS.sub("", conditional)
                conditional = LibMakefile._LIBNAME.sub("{libname}_{libext}_\\1".format(**kwargs), conditional)
                conditional = conditional.replace("lib%_LIBRARIES", "lib_LIBRARIES")
                conditional = conditional.replace("lib%_LTLIBRARIES", "lib_LTLIBRARIES")
                if transform_check_PROGRAMS:
                    conditional = conditional.replace("check_PROGRAMS", "noinst_PROGRAMS")
                conditional = conditional.replace(r"${gl_include_guard_prefix}", config.include_guard_prefix)
                unconditional = module.unconditional_automake_snippet(config.auxdir)
                unconditional = LibMakefile._LIBNAME.sub("{libname}_{libext}_\\1".format(**kwargs), unconditional)
                if (conditional + unconditional).strip():
                    lines.append("## begin gnulib module {}".format(module.name))
                    if module.name == "alloca":
                        lines.append("{libname}_{libext}_LIBADD += @{perhaps_LT}ALLOCA@".format(**kwargs))
                        lines.append("{libname}_{libext}_DEPENDENCIES += @{perhaps_LT}ALLOCA@".format(**kwargs))
                    lines += list(process(module, conditional, unconditional))
                    lines.append("## end   gnulib module {}".format(module.name))
                    lines.append("")
            return (uses_subdirs, lines)

        (uses_subdirs, overall_snippet) = _snippet()
        if "makefile_name" not in explicit:
            # If there are source files in subdirectories, prevent collision of the
            # object files (example: hash.c and libxml/hash.c).
            yield "AUTOMAKE_OPTIONS = 1.9.6 gnits{}".format(" subdir-objects" if uses_subdirs else "")
        yield ""
        if "makefile_name" not in explicit:
            yield "SUBDIRS ="
            yield "noinst_HEADERS ="
            yield "noinst_LIBRARIES ="
            yield "noinst_LTLIBRARIES ="
            # Automake versions < 1.11.4 create an empty pkgdatadir at
            # installation time if you specify pkgdata_DATA to empty.
            # See automake bugs #10997 and #11030:
            #  * http://debbugs.gnu.org/10997
            #  * http://debbugs.gnu.org/11030
            # So we need this workaround.
            if {line for line in overall_snippet if line.startswith()}:
                yield "pkgdata_DATA ="
            yield "EXTRA_DIST ="
            yield "BUILT_SOURCES ="
            yield "SUFFIXES ="
        yield "MOSTLYCLEANFILES {} core *.stackdump".format(assign)
        if "makefile_name" not in explicit:
            yield "MOSTLYCLEANDIRS ="
            yield "CLEANFILES ="
            yield "DISTCLEANFILES ="
            yield "MAINTAINERCLEANFILES ="

        if gnumake:
            yield "# Start of GNU Make output."
            self.__autoconf = "autoconf"
            self.__configure_ac = "configure.ac"
            cmdargs = (self.__autoconf, "-t", "AC_SUBST:$1 = @$1@", self.__configure_ac)
            with _sp.Popen(cmdargs, stdout=_sp.PIPE, stderr=_sp.PIPE) as process:
                (stdout, stderr) = process.communicate()
                stdout = stdout.decode("UTF-8")
                stderr = stderr.decode("UTF-8")
                if process.returncode == 0:
                    for line in sorted(stdout.splitlines()):
                        yield line
                else:
                    yield "== gnulib-tool GNU Make output failed as follows =="
                    for line in stderr.splitlines():
                        yield "# stderr: {}".format(line)
            yield "# End of GNU Make output."
        else:
            yield "# No GNU Make output."

        for (directory, key, value) in self.__mkedits:
            if key and _os.path.join(directory, "Makefile.am") == self.__path:
                yield f"{key} += {value}"

        cppflags = "".join((
            " -D{}=1".format(config.witness_c_macro) if "witness_c_macro" in explicit else "",
            " -DGNULIB_STRICT_CHECKING=1" if for_test else "",
        ))
        if "makefile_name" not in explicit:
            yield ""
            yield "AM_CPPFLAGS ={}".format(cppflags)
            yield "AM_CFLAGS ="
        elif "".join(cppflags):
            yield ""
            yield "AM_CPPFLAGS +={}".format(cppflags)
        yield ""

        snippet = "\n".join(overall_snippet)
        if "makefile_name" in explicit:
            makefile = _os.path.join(config.source_base, "Makefile.am")
            if _os.path.exists(makefile):
                with _codecs.open(makefile, "rb", "UTF-8") as stream:
                    snippet += ("\n" + stream.read())
        # One of the snippets or the user's Makefile.am already specifies an
        # installation location for the library. Don't confuse automake by saying
        # it should not be installed.
        # By default, the generated library should not be installed.
        regex = "^[a-zA-Z0-9_]*_{perhaps_LT}LIBRARIES\\s*\\+?\\=\\s*{libname}\\.{libext}$"
        pattern = _re.compile(regex.format(**kwargs), _re.S)
        if not pattern.findall(snippet):
            yield "noinst_{perhaps_LT}LIBRARIES += {libname}.{libext}".format(**kwargs)

        yield ""
        yield "{libname}_{libext}_SOURCES =".format(**kwargs)
        # Here we use $(LIBOBJS), not @LIBOBJS@. The value is the same. However,
        # automake during its analysis looks for $(LIBOBJS), not for @LIBOBJS@.
        yield "{libname}_{libext}_LIBADD = $({macro_prefix}_{perhaps_LT}LIBOBJS)".format(**kwargs)
        yield "{libname}_{libext}_DEPENDENCIES = $({macro_prefix}_{perhaps_LT}LIBOBJS)".format(**kwargs)
        yield "EXTRA_{libname}_{libext}_SOURCES =".format(**kwargs)
        if libtool:
            yield "{libname}_{libext}_LDFLAGS = $(AM_LDFLAGS)".format(**kwargs)
            yield "{libname}_{libext}_LDFLAGS += -no-undefined".format(**kwargs)
            # Synthesize an ${libname}_${libext}_LDFLAGS augmentation by combining
            # the link dependencies of all modules.
            def _directives(modules):
                directives = (module.link_directive for module in sorted(modules))
                for directive in filter(lambda directive: directive.strip(), directives):
                    index = directive.find("when linking with libtool")
                    if index != -1:
                        directive = directive[:index].strip(" ")
                    yield directive
            for directive in sorted(set(_directives(modules))):
                yield ("{libname}_{libext}_LDFLAGS += {directive}".format(directive=directive, **kwargs))
        yield ""

        if "po_base" in explicit:
            yield "AM_CPPFLAGS += -DDEFAULT_TEXT_DOMAIN=\\\"{}-gnulib\\\"".format(config.po_domain)
            yield ""

        for line in overall_snippet:
            yield line.replace("$(top_srcdir)/build-aux/", _os.path.join("$(top_srcdir)", config.auxdir))
        yield ""
        yield "mostlyclean-local: mostlyclean-generic"
        yield "\t@for dir in '' $(MOSTLYCLEANDIRS); do \\"
        yield "\t  if test -n \"$$dir\" && test -d $$dir; then \\"
        yield "\t    echo \"rmdir $$dir\"; rmdir $$dir; \\"
        yield "\t  fi; \\"
        yield "\tdone; \\"
        yield "\t:"



class GnulibCache(Base):
    def __init__(self, config):
        _type_assert("config", config, _BaseConfig)
        self.__config = config


    def __iter__(self):
        date = _datetime.now()
        config = self.__config
        yield "## DO NOT EDIT! GENERATED AUTOMATICALLY!"
        yield "## Process this file with automake to produce Makefile.in."
        yield "# Copyright (C) 2002-{} Free Software Foundation, Inc.".format(date.year)
        for line in super().__iter__():
            yield line
        yield "#"
        yield "# This file represents the specification of how gnulib-tool is used."
        yield "# It acts as a cache: It is written and read by gnulib-tool."
        yield "# In projects that use version control, this file is meant to be put under"
        yield "# version control, like the configure.ac and various Makefile.am files."
        yield ""
        yield ""
        yield "# Specification in the form of a command-line invocation:"
        yield "gl_LOCAL_DIR([$relative_local_gnulib_path])"
        yield "gl_MODULES(["
        for module in sorted(config.modules):
            yield "  {}".format(module)
        yield "])"
        if config.obsolete:
            yield "gl_WITH_OBSOLETE"
        if config.cxx_tests:
            yield "gl_WITH_CXX_TESTS"
        if config.longrunning_tests:
            yield "gl_WITH_LONGRUNNING_TESTS"
        if config.privileged_tests:
            yield "gl_WITH_PRIVILEGED_TESTS"
        if config.unportable_tests:
            yield "gl_WITH_UNPORTABLE_TESTS"
        if config.all_tests:
            yield "gl_WITH_ALL_TESTS"
        yield "gl_AVOID([{}])".format(" ".join(sorted(config.avoids)))
        yield "gl_SOURCE_BASE([{}])".format(config.source_base)
        yield "gl_M4_BASE([{}])".format(config.m4_base)
        yield "gl_PO_BASE([{}])".format(config.po_base)
        yield "gl_DOC_BASE([{}])".format(config.doc_base)
        yield "gl_TESTS_BASE([{}])".format(config.tests_base)
        if config.tests:
            yield "gl_WITH_TESTS"
        yield "gl_LIB([{}])".format(config.libname)
        if config.licenses in _LGPL:
            lgpl = _LGPL[config.licenses]
            yield "gl_LGPL([{}])".format(lgpl) if lgpl != "yes" else "gl_LGPL"
        yield "gl_MAKEFILE_NAME([{}])".format(config.makefile_name)
        if config.conddeps:
            yield "gl_CONDITIONAL_DEPENDENCIES"
        if config.libtool:
            yield "gl_LIBTOOL"
        yield "gl_MACRO_PREFIX([{}])".format(config.macro_prefix)
        yield "gl_PO_DOMAIN([{}])".format(config.po_domain)
        yield "gl_WITNESS_C_MACRO([{}])".format(config.witness_c_macro)
        if config.vc_files:
            yield "gl_VC_FILES([{}])".format(" ".join(sorted(config.vc_files)))
