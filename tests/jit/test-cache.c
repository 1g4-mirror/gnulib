/* Test clear_cache.

   Copyright 2020-2024 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

#include <config.h>

/* Specification.  */
#include <jit/cache.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#if HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

#if defined __APPLE__ && defined __MACH__ /* only needed on macOS */
# define KEEP_TEMP_FILE_VISIBLE
/* Support for temporary files that are cleaned up automatically. */
# include "clean-temp-simple.h"
#endif

#include "macros.h"

/*  On most platforms, function pointers are just a pointer to the
    code, i.e. to the first instruction to be executed.  This,
    however, is not universally true, see:
    https://git.savannah.gnu.org/gitweb/?p=libffcall.git;a=blob;f=porting-tools/abis/function-pointer.txt.  */

#define CODE(fn) (((struct func *) (fn))->code_address)
#if ((defined __powerpc__ || defined __powerpc64__) && defined _AIX) || (defined __powerpc64__ && defined __linux__)
struct func
{
  void *code_address;
  void *toc_pointer;
  void *static_chain;
};
#elif defined __ia64__
# if defined __ia64_ilp32__
struct func
{
  void *code_address;
  void *unused1;
  void *global_pointer;
  void *unused2;
};
# else
struct func
{
  void *code_address;
  void *global_pointer;
};
# endif
#elif defined __hppa__
# if defined __hppa64__
struct func
{
  void *some_other_code_address;
  void *some_other_pic_base;
  void *code_address;
  void *pic_base;
};
# else
struct func
{
  void *code_address;
  void *pic_base;
};
# endif
#else
# undef CODE
# define CODE(fn) ((*(void **) (&fn)))
#endif

/* This test assumes that the code generated by the compiler for the
   procedures `return1' and `return2' is position independent.  It
   also assumes that data pointers are bit-compatible to integers.  */

static int
return1 (void)
{
  return 1;
}

static int
return2 (void)
{
  return 2;
}

int
main ()
{
#if defined _RET_PROTECTOR
  /* The OpenBSD "retguard" stack protector produces code for 'return1' and
     'return2' that is not position independent, and there is no clang
     attribute for turning this instrumentation off for specific functions.
     If this stack protector has not been disabled through a configure test,
     we need to skip this unit test.  */
  return 77;
#else
  int const pagesize = getpagesize ();
  int const mapping_size = 1 * pagesize;
  /* Bounds of an executable memory region.  */
  char *start;
  char *end;
  /* Start of a writable memory region.  */
  char *start_rw;

  /* Initialization.  */
  {
# if defined _WIN32 && !defined __CYGWIN__
    /* VirtualAlloc
       <https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc>
       <https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants> */
    start = VirtualAlloc (NULL, mapping_size, MEM_COMMIT,
                          PAGE_EXECUTE_READWRITE);
    if (start == NULL)
      return 1;
    start_rw = start;
# else
#  ifdef HAVE_MAP_ANONYMOUS
    int flags = MAP_ANONYMOUS | MAP_PRIVATE;
    int fd = -1;
#  else
    int flags = MAP_FILE | MAP_PRIVATE;
    int fd = open ("/dev/zero", O_RDONLY | O_CLOEXEC, 0666);
    if (fd < 0)
      return 1;
#  endif
    start = mmap (NULL, mapping_size, PROT_READ | PROT_WRITE | PROT_EXEC,
                  flags, fd, 0);
    if (start != (char *) (-1))
      {
        /* A platform that allows a mmap'ed memory region to be simultaneously
           writable and executable.  */
        start_rw = start;
      }
    else
      {
        /* A platform which requires the writable mapping and the executable
           mapping to be separate: macOS, FreeBSD, NetBSD, OpenBSD.  */
        fprintf (stderr, "simple mmap failed, using separate mappings\n");
        char filename[100];
        sprintf (filename,
                 "%s/gnulib-test-cache-%u-%d-%ld",
                 "/tmp", (unsigned int) getuid (), (int) getpid (), random ());
#  ifdef KEEP_TEMP_FILE_VISIBLE
        if (register_temporary_file (filename) < 0)
          return 2;
#  endif
        fd = open (filename, O_CREAT | O_RDWR | O_TRUNC, 0700);
        if (fd < 0)
          return 3;
#  ifndef KEEP_TEMP_FILE_VISIBLE
        /* Remove the file from the file system as soon as possible, to make
           sure there is no leftover after this process terminates or crashes.
           On macOS 11.2, this does not work: It would make the mmap call below,
           with arguments PROT_READ|PROT_EXEC and MAP_SHARED, fail. */
        unlink (filename);
#  endif
        if (ftruncate (fd, mapping_size) < 0)
          return 4;
        start = mmap (NULL, mapping_size, PROT_READ | PROT_EXEC, MAP_SHARED,
                      fd, 0);
        start_rw = mmap (NULL, mapping_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                         fd, 0);
        if (start == (char *) (-1) || start_rw == (char *) (-1))
          return 5;
      }
# endif
    end = start + mapping_size;
  }

  int (*f) (void) = return1;
  CODE (f) = start;

  /* We assume that the code is not longer than 64 bytes and that we
     can access the full 64 bytes for reading.  */
  memcpy (start_rw, return1, 64);
  clear_cache (start, end);
  ASSERT (f () == 1);

  memcpy (start_rw, return2, 64);
  clear_cache (start, end);
  ASSERT (f () == 2);

  return 0;
#endif  /* !(HAVE_SYS_MMAN_H && HAVE_PROTECT) */
}
